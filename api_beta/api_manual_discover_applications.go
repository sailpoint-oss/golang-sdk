/*
IdentityNow Beta API

Use these APIs to interact with the IdentityNow platform to achieve repeatable, automated processes with greater scalability. These APIs are in beta and are subject to change. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.

API version: 3.1.0-beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api_beta

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// ManualDiscoverApplicationsAPIService ManualDiscoverApplicationsAPI service
type ManualDiscoverApplicationsAPIService service

type ApiSendManualDiscoverApplicationsCsvTemplateRequest struct {
	ctx context.Context
	ApiService *ManualDiscoverApplicationsAPIService
	csvFile *os.File
}

func (r ApiSendManualDiscoverApplicationsCsvTemplateRequest) CsvFile(csvFile *os.File) ApiSendManualDiscoverApplicationsCsvTemplateRequest {
	r.csvFile = csvFile
	return r
}

func (r ApiSendManualDiscoverApplicationsCsvTemplateRequest) Execute() (*ManualDiscoverApplications, *http.Response, error) {
	return r.ApiService.SendManualDiscoverApplicationsCsvTemplateExecute(r)
}

/*
SendManualDiscoverApplicationsCsvTemplate CSV Upload to discover applications

This API allows for the upload of a CSV file containing application data to be manually correlated to potential IDN connector(s).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendManualDiscoverApplicationsCsvTemplateRequest
*/
func (a *ManualDiscoverApplicationsAPIService) SendManualDiscoverApplicationsCsvTemplate(ctx context.Context) ApiSendManualDiscoverApplicationsCsvTemplateRequest {
	return ApiSendManualDiscoverApplicationsCsvTemplateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManualDiscoverApplications
func (a *ManualDiscoverApplicationsAPIService) SendManualDiscoverApplicationsCsvTemplateExecute(r ApiSendManualDiscoverApplicationsCsvTemplateRequest) (*ManualDiscoverApplications, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ManualDiscoverApplications
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManualDiscoverApplicationsAPIService.SendManualDiscoverApplicationsCsvTemplate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/manual-discover-applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.csvFile == nil {
		return localVarReturnValue, nil, reportError("csvFile is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"multipart/form-data", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var csvFileLocalVarFormFileName string
	var csvFileLocalVarFileName     string
	var csvFileLocalVarFileBytes    []byte

	csvFileLocalVarFormFileName = "csvFile"
	csvFileLocalVarFile := r.csvFile

	if csvFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(csvFileLocalVarFile)

		csvFileLocalVarFileBytes = fbs
		csvFileLocalVarFileName = csvFileLocalVarFile.Name()
		csvFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: csvFileLocalVarFileBytes, fileName: csvFileLocalVarFileName, formFileName: csvFileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListAccessProfiles401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ListAccessProfiles429Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
